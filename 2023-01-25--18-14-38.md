# Event-sourcing into working memory to improve data access latency

In this article, we describe a modernization, moving from a database-centric access pattern, towards event-sourcing data changes directly into the application's working memory (RAM). 

## Modernization scenario

### Introduction and a na√Øve starting point

The modernization started with a 'traditional' web application, which leverages both internal data, as well as calling into external APIs. In our scenario, the internal data represents configuration information necessary for the business logic in the app to handle the responses from the external APIs. An example could be an e-commerce site, which calls various external catalogues for goods, and applies business rules to the aggregated result. The internal configuration data in this scenario could e.g. be markup rules or the list of external APIs which can be called. When the business onboards a new catalogue provider, the admin team would update the internal configuration database with the new catalogue configuration. 

During request handling, the web app needs to query the internal configuration database to retrieve the current list of external dependencies such as catalogues, business rule configurations, etc.. The configuration information can change during normal operations, so the application developer has to work on a strategy to determine how often the underlying config database should be queried. In the worst case, the web application must query the configuration database multiple times, for example to determine the different external providers, as well as to retrieve per-provider business rules. 

Querying the configuration source on a per-request basis ensures to always work on the most recent configuration, but adds considerable load to the configuration database, increases the end-to-end latency of each request and therefore reduces the overall capacity of a web application node.

The diagram below describes our starting point, with the client sending requests to the load balancer (a), the load balancer distributing incoming requests to the application servers running the web application (b), and the web application querying both the configuration source (c), as well as the external dependencies (d). The *configuration source* abstractly represents the actor that changes the configuration, which could be business administrators, or automated processes.

![01-Regular-SQL](2023-01-25--event-sourcing-1_01-Regular-SQL.png)

### Brute-force in-memory state using caching in the ORM

Accessing a relational database like our configuration database often is implemented using an object relational mapper (ORM) technology, such as .NET Entity Framework (EF). ORMs support caching query results in memory, so that the amount of database  queries can be significantly reduced. 

In the diagram below, we represent the ORM as a 'local cache' inside the web application:

![02-Cached-SQL](2023-01-25--event-sourcing-1_02-Cached-SQL.png)





EventSourcing-Pure

![03-EventSourcing-Pure](2023-01-25--event-sourcing-1_03-EventSourcing-Pure.png)





EventSourcing-with

![04-EventSourcing-with-Snapshots](2023-01-25--event-sourcing-1_04-EventSourcing-with-Snapshots.png)





DataPump](

![05-DataPump](2023-01-25--event-sourcing-1_05-DataPump.png)





EventSourcing-Start

![07-EventSourcing-Start](2023-01-25--event-sourcing-1_07-EventSourcing-Start.png)





EventSourcing-ResumeHot

![08-EventSourcing-ResumeHot](2023-01-25--event-sourcing-1_08-EventSourcing-ResumeHot.png)





09-EventSourcing

![09-EventSourcing-ResumeFromCapture](2023-01-25--event-sourcing-1_09-EventSourcing-ResumeFromCapture.png)

